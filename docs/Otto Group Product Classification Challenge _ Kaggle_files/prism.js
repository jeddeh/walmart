/* http://prismjs.com/download.html?themes=prism&languages=julia+python+r+sql&plugins=line-numbers */
self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {}; var Prism = function () { var e = /\blang(?:uage)?-(?!\*)(\w+)\b/i, t = self.Prism = { util: { encode: function (e) { return e instanceof n ? new n(e.type, t.util.encode(e.content), e.alias) : "Array" === t.util.type(e) ? e.map(t.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ") }, type: function (e) { return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1] }, clone: function (e) { var n = t.util.type(e); switch (n) { case "Object": var a = {}; for (var r in e) e.hasOwnProperty(r) && (a[r] = t.util.clone(e[r])); return a; case "Array": return e.map(function (e) { return t.util.clone(e) }) } return e } }, languages: { extend: function (e, n) { var a = t.util.clone(t.languages[e]); for (var r in n) a[r] = n[r]; return a }, insertBefore: function (e, n, a, r) { r = r || t.languages; var i = r[e]; if (2 == arguments.length) { a = arguments[1]; for (var l in a) a.hasOwnProperty(l) && (i[l] = a[l]); return i } var s = {}; for (var o in i) if (i.hasOwnProperty(o)) { if (o == n) for (var l in a) a.hasOwnProperty(l) && (s[l] = a[l]); s[o] = i[o] } return t.languages.DFS(t.languages, function (t, n) { n === r[e] && t != e && (this[t] = s) }), r[e] = s }, DFS: function (e, n, a) { for (var r in e) e.hasOwnProperty(r) && (n.call(e, r, e[r], a || r), "Object" === t.util.type(e[r]) ? t.languages.DFS(e[r], n) : "Array" === t.util.type(e[r]) && t.languages.DFS(e[r], n, r)) } }, highlightAll: function (e, n) { for (var a, r = document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'), i = 0; a = r[i++];) t.highlightElement(a, e === !0, n) }, highlightElement: function (a, r, i) { for (var l, s, o = a; o && !e.test(o.className) ;) o = o.parentNode; if (o && (l = (o.className.match(e) || [, ""])[1], s = t.languages[l]), a.className = a.className.replace(e, "").replace(/\s+/g, " ") + " language-" + l, o = a.parentNode, /pre/i.test(o.nodeName) && (o.className = o.className.replace(e, "").replace(/\s+/g, " ") + " language-" + l), s) { var u = a.textContent; if (u) { u = u.replace(/^(?:\r?\n|\r)/, ""); var g = { element: a, language: l, grammar: s, code: u }; if (t.hooks.run("before-highlight", g), r && self.Worker) { var c = new Worker(t.filename); c.onmessage = function (e) { g.highlightedCode = n.stringify(JSON.parse(e.data), l), t.hooks.run("before-insert", g), g.element.innerHTML = g.highlightedCode, i && i.call(g.element), t.hooks.run("after-highlight", g) }, c.postMessage(JSON.stringify({ language: g.language, code: g.code })) } else g.highlightedCode = t.highlight(g.code, g.grammar, g.language), t.hooks.run("before-insert", g), g.element.innerHTML = g.highlightedCode, i && i.call(a), t.hooks.run("after-highlight", g) } } }, highlight: function (e, a, r) { var i = t.tokenize(e, a); return n.stringify(t.util.encode(i), r) }, tokenize: function (e, n) { var a = t.Token, r = [e], i = n.rest; if (i) { for (var l in i) n[l] = i[l]; delete n.rest }e: for (var l in n) if (n.hasOwnProperty(l) && n[l]) { var s = n[l]; s = "Array" === t.util.type(s) ? s : [s]; for (var o = 0; o < s.length; ++o) { var u = s[o], g = u.inside, c = !!u.lookbehind, f = 0, h = u.alias; u = u.pattern || u; for (var p = 0; p < r.length; p++) { var d = r[p]; if (r.length > e.length) break e; if (!(d instanceof a)) { u.lastIndex = 0; var m = u.exec(d); if (m) { c && (f = m[1].length); var y = m.index - 1 + f, m = m[0].slice(f), v = m.length, k = y + v, b = d.slice(0, y + 1), w = d.slice(k + 1), N = [p, 1]; b && N.push(b); var O = new a(l, g ? t.tokenize(m, g) : m, h); N.push(O), w && N.push(w), Array.prototype.splice.apply(r, N) } } } } } return r }, hooks: { all: {}, add: function (e, n) { var a = t.hooks.all; a[e] = a[e] || [], a[e].push(n) }, run: function (e, n) { var a = t.hooks.all[e]; if (a && a.length) for (var r, i = 0; r = a[i++];) r(n) } } }, n = t.Token = function (e, t, n) { this.type = e, this.content = t, this.alias = n }; if (n.stringify = function (e, a, r) { if ("string" == typeof e) return e; if ("Array" === t.util.type(e)) return e.map(function (t) { return n.stringify(t, a, e) }).join(""); var i = { type: e.type, content: n.stringify(e.content, a, r), tag: "span", classes: ["token", e.type], attributes: {}, language: a, parent: r }; if ("comment" == i.type && (i.attributes.spellcheck = "true"), e.alias) { var l = "Array" === t.util.type(e.alias) ? e.alias : [e.alias]; Array.prototype.push.apply(i.classes, l) } t.hooks.run("wrap", i); var s = ""; for (var o in i.attributes) s += o + '="' + (i.attributes[o] || "") + '"'; return "<" + i.tag + ' class="' + i.classes.join(" ") + '" ' + s + ">" + i.content + "</" + i.tag + ">" }, !self.document) return self.addEventListener ? (self.addEventListener("message", function (e) { var n = JSON.parse(e.data), a = n.language, r = n.code; self.postMessage(JSON.stringify(t.util.encode(t.tokenize(r, t.languages[a])))), self.close() }, !1), self.Prism) : self.Prism; var a = document.getElementsByTagName("script"); return a = a[a.length - 1], a && (t.filename = a.src, document.addEventListener && !a.hasAttribute("data-manual") && document.addEventListener("DOMContentLoaded", t.highlightAll)), self.Prism }(); "undefined" != typeof module && module.exports && (module.exports = Prism);;
Prism.languages.julia = { comment: { pattern: /(^|[^\\])#.*?(\r?\n|$)/, lookbehind: !0 }, string: /"""[\s\S]+?"""|'''[\s\S]+?'''|("|')(\\?.)*?\1/, keyword: /\b(abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|let|local|macro|module|print|println|quote|return|try|type|typealias|using|while)\b/, "boolean": /\b(true|false)\b/, number: /\b-?(0[box])?(?:[\da-f]+\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i, operator: /[-+]{1,2}|=?<|=?>|!|={1,2}|&{1,2}|\|?\||\?|\*|\/|~|\^|%|\b(or|and|not)\b/, punctuation: /[{}[\];(),.:]/ };;
Prism.languages.python = { comment: { pattern: /(^|[^\\])#.*?(\r?\n|$)/, lookbehind: !0 }, string: /"""[\s\S]+?"""|'''[\s\S]+?'''|("|')(\\?.)*?\1/, "function": { pattern: /((^|\s)def[ \t]+)([a-zA-Z_][a-zA-Z0-9_]*(?=\())/g, lookbehind: !0 }, keyword: /\b(as|assert|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/, "boolean": /\b(True|False)\b/, number: /\b-?(0[bo])?(?:(\d|0x[a-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i, operator: /[-+]|<=?|>=?|!|={1,2}|&{1,2}|\|?\||\?|\*|\/|~|\^|%|\b(or|and|not)\b/, punctuation: /[{}[\];(),.:]/ };;
Prism.languages.r = { comment: /#.+/, string: /(['"])(?:\\?.)*?\1/, "percent-operator": { pattern: /%[^%]*?%/, alias: "operator" }, "boolean": /\b(?:TRUE|FALSE)\b/, ellipsis: /\.\.(?:\.|\d+)/, number: [/\b(?:NaN|Inf)\b/, /\b(?:0x[\dA-Fa-f]+(?:\.\d*)?|\d*\.?\d+)(?:[EePp][+-]??\d+)?[iL]?\b/], keyword: /\b(?:if|else|repeat|while|function|for|in|next|break|NULL|NA|NA_integer_|NA_real_|NA_complex_|NA_character_)\b/, operator: /->>?|<?<-|[<>!=]=?|::?|&&?|\|\|?|[+\-*\/^$@~]/, punctuation: /[(){}\[\],;]/ };;
Prism.languages.sql = { comment: { pattern: /(^|[^\\])(\/\*[\w\W]*?\*\/|((--)|(\/\/)|#).*?(\r?\n|$))/, lookbehind: !0 }, string: { pattern: /(^|[^@])("|')(\\?[\s\S])*?\2/, lookbehind: !0 }, variable: /@[\w.$]+|@("|'|`)(\\?[\s\S])+?\1/, "function": /\b(?:COUNT|SUM|AVG|MIN|MAX|FIRST|LAST|UCASE|LCASE|MID|LEN|ROUND|NOW|FORMAT)(?=\s*\()/i, keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALTER|ANALYZE|APPLY|AS|ASC|AUTHORIZATION|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADE|CASCADED|CASE|CHAIN|CHAR VARYING|CHARACTER VARYING|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLUMN|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|CURRENT_USER|CURSOR|DATA|DATABASE|DATABASES|DATETIME|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DOUBLE PRECISION|DROP|DUMMY|DUMP|DUMPFILE|DUPLICATE KEY|ELSE|ENABLE|ENCLOSED BY|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPE|ESCAPED BY|EXCEPT|EXEC|EXECUTE|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR|FOR EACH ROW|FORCE|FOREIGN|FREETEXT|FREETEXTTABLE|FROM|FULL|FUNCTION|GEOMETRY|GEOMETRYCOLLECTION|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|IDENTITY|IDENTITY_INSERT|IDENTITYCOL|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTO|INVOKER|ISOLATION LEVEL|JOIN|KEY|KEYS|KILL|LANGUAGE SQL|LAST|LEFT|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONGBLOB|LONGTEXT|MATCH|MATCHED|MEDIUMBLOB|MEDIUMINT|MEDIUMTEXT|MERGE|MIDDLEINT|MODIFIES SQL DATA|MODIFY|MULTILINESTRING|MULTIPOINT|MULTIPOLYGON|NATIONAL|NATIONAL CHAR VARYING|NATIONAL CHARACTER|NATIONAL CHARACTER VARYING|NATIONAL VARCHAR|NATURAL|NCHAR|NCHAR VARCHAR|NEXT|NO|NO SQL|NOCHECK|NOCYCLE|NONCLUSTERED|NULLIF|NUMERIC|OF|OFF|OFFSETS|ON|OPEN|OPENDATASOURCE|OPENQUERY|OPENROWSET|OPTIMIZE|OPTION|OPTIONALLY|ORDER|OUT|OUTER|OUTFILE|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC|PROCEDURE|PUBLIC|PURGE|QUICK|RAISERROR|READ|READS SQL DATA|READTEXT|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURN|RETURNS|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROWCOUNT|ROWGUIDCOL|ROWS?|RTREE|RULE|SAVE|SAVEPOINT|SCHEMA|SELECT|SERIAL|SERIALIZABLE|SESSION|SESSION_USER|SET|SETUSER|SHARE MODE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|START|STARTING BY|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLE|TABLES|TABLESPACE|TEMP(?:ORARY)?|TEMPTABLE|TERMINATED BY|TEXT|TEXTSIZE|THEN|TIMESTAMP|TINYBLOB|TINYINT|TINYTEXT|TO|TOP|TRAN|TRANSACTION|TRANSACTIONS|TRIGGER|TRUNCATE|TSEQUAL|TYPE|TYPES|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNPIVOT|UPDATE|UPDATETEXT|USAGE|USE|USER|USING|VALUE|VALUES|VARBINARY|VARCHAR|VARCHARACTER|VARYING|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH|WITH ROLLUP|WITHIN|WORK|WRITE|WRITETEXT)\b/i, "boolean": /\b(?:TRUE|FALSE|NULL)\b/i, number: /\b-?(0x)?\d*\.?[\da-f]+\b/, operator: /\b(?:ALL|AND|ANY|BETWEEN|EXISTS|IN|LIKE|NOT|OR|IS|UNIQUE|CHARACTER SET|COLLATE|DIV|OFFSET|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b|[-+]|!|[=<>]{1,2}|(&){1,2}|\|?\||\?|\*|\//i, punctuation: /[;[\]()`,.]/ };;
Prism.hooks.add("after-highlight", function (e) { var t = e.element.parentNode, s = /\s*\bline-numbers\b\s*/; if (t && /pre/i.test(t.nodeName) && (s.test(t.className) || s.test(e.element.className))) { s.test(e.element.className) && (e.element.className = e.element.className.replace(s, "")), s.test(t.className) || (t.className += " line-numbers"); var a, n = 1 + e.code.split("\n").length, l = new Array(n); l = l.join("<span></span>"), a = document.createElement("span"), a.className = "line-numbers-rows", a.innerHTML = l, t.hasAttribute("data-start") && (t.style.counterReset = "linenumber " + (parseInt(t.getAttribute("data-start"), 10) - 1)), e.element.appendChild(a) } });;
